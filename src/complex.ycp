/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	include/audit-laf/complex.ycp
 * Package:	Configuration of Linux Auditing
 * Summary:	Dialogs definitions
 * Authors:	Gabriele Mohr <gs@suse.de>
 *
 */

{

textdomain "audit-laf";

import "Label";
import "Popup";
import "Wizard";
import "Wizard_hw";
import "Confirm";
import "AuditLaf";
import "Report";

include "audit-laf/helps.ycp";

/**
 * Return a modification status
 * @return true if data was modified
 */
boolean Modified() {
    return AuditLaf::Modified();
}

boolean ReallyAbort() {
    return !AuditLaf::Modified() || Popup::ReallyAbort(true);
}

/**
 * Read settings dialog
 * @return `abort if aborted and `next otherwise
 */
symbol ReadDialog() {
    Wizard::RestoreHelp(HELPS["read"]:"");

    if (!Confirm::MustBeRoot()) return `abort;
    boolean ret = AuditLaf::Read();
    return ret ? `next : `abort;
}

/**
 * Write settings dialog
 * @return `abort if aborted and `next otherwise
 */
symbol WriteDialog() {
    Wizard::RestoreHelp(HELPS["write"]:"");

    boolean ret = AuditLaf::Write();
    return ret ? `next : `abort;
}

void InitLogfileSettingsDialog (string id) {

    UI::ChangeWidget( `id("max_log_file"), `ValidChars, "0123456789" );

    // Set all values to values read from /etc/audit/auditd.conf
    UI::ChangeWidget( `id("freq"), `Value, tointeger( AuditLaf::GetAuditdOption("freq")) );
    UI::ChangeWidget( `id("num_logs"), `Value, tointeger( AuditLaf::GetAuditdOption("num_logs")) );		      
    foreach (string key, ["log_file",
			  "max_log_file",
			  "action_mail_acct",
			  "name"
			  ], {
	UI::ChangeWidget(`id(key), `Value, (AuditLaf::GetAuditdOption(key)));
    });

    foreach (string key, ["log_format",
			  "flush",
			  "max_log_file_action",
			  "name_format"
			  ], {
		 UI::ChangeWidget(`id(key), `Value, toupper(AuditLaf::GetAuditdOption(key)) );
    });
    
    
    y2milestone( "Init log file settings");
}

symbol HandleLogfileSettingsDialog(string id, map event) {
    any action = event["ID"]:nil; 

    if ( action == "select_file" )
    {
	string file_name = UI::AskForExistingFile("/var/log/audit", "*.log", _("Select the log file") );

	UI::ChangeWidget( `id("log_file"), `Value, file_name );
	y2milestone( "Logfile set to: %1", file_name );  
    }
    return nil;
}

boolean ReallyExit () {
    // yes-no popup
    return Popup::YesNo (_("Really exit?
All changes will be lost."));
}

void StoreLogfileSettingsDialog (string id, map event) {

    AuditLaf::SetModified( true );

    // Store all values in SETTINGS
    AuditLaf::SetAuditdOption( "freq", tostring( (integer)UI::QueryWidget( `id("freq"), `Value ) ) );
    AuditLaf::SetAuditdOption( "num_logs", tostring( (integer)UI::QueryWidget( `id("num_logs"), `Value ) ) ); 

    foreach (string key, ["log_file",
			  "log_format",
			  "max_log_file",
			  "flush",
			  "max_log_file_action",
			  "action_mail_acct",
			  "name_format",
			  "name"
			  ], {
	AuditLaf::SetAuditdOption( key, (string) UI::QueryWidget(`id(key), `Value) );
    });
    y2milestone( "Store log file settings" );

}
void InitDispatcherDialog (string id) {

    // Set all values to values read from /etc/audit/auditd.conf
    foreach (string key, ["dispatcher",
			  "disp_qos" ], {
	UI::ChangeWidget(`id(key), `Value, (AuditLaf::GetAuditdOption(key)));
    });
    
    y2milestone( "Init dispatcher dialog" );
}

symbol HandleDispatcherDialog(string id, map event) {
    any action = event["ID"]:nil; 

    if ( action == "select_disp" )
    {
	string file_name = UI::AskForExistingFile("/sbin", "*", _("Select the dispatcher program") );

	UI::ChangeWidget( `id("dispatcher"), `Value, file_name );
	y2milestone( "Dispatcher program set to: %1", file_name );  
    }
    return nil;
}

void StoreDispatcherDialog (string id, map event) {

    AuditLaf::SetModified( true );

   // Store all values in SETTINGS
    foreach (string key, ["dispatcher",
			  "disp_qos"], {
	AuditLaf::SetAuditdOption( key, (string) UI::QueryWidget(`id(key), `Value) );
    });

    y2milestone( "Store dispatcher dialog" );
}


void InitDiskspaceSettingsDialog (string id) {
    UI::ChangeWidget( `id("space_left"), `ValidChars, "0123456789" );
    UI::ChangeWidget( `id("admin_space_left"), `ValidChars, "0123456789" );
 
    // Set all values to values read from /etc/audit/auditd.conf
    foreach (string key, ["space_left",
			  "admin_space_left"
			  ], {
	UI::ChangeWidget(`id(key), `Value, (AuditLaf::GetAuditdOption(key)));
    });

    foreach (string key, ["space_left_action",
			  "admin_space_left_action",
			  "disk_full_action",
			  "disk_error_action"
			  ], {
	UI::ChangeWidget(`id(key), `Value, toupper(AuditLaf::GetAuditdOption(key)) );
    });

    
    y2milestone( "Init disk space settings" );
}

void StoreDiskspaceSettingsDialog (string id, map event) {
    AuditLaf::SetModified( true );

    foreach (string key, ["space_left",
			  "admin_space_left",
			  "space_left_action",
			  "admin_space_left_action",
			  "disk_full_action",
			  "disk_error_action"
			  ], {
	AuditLaf::SetAuditdOption( key, (string) UI::QueryWidget(`id(key), `Value) );
    });
    
    y2milestone( "Store disk space settings" );
}

void InitRulesDialog( string id )   {
    string rules =  AuditLaf::GetRules();
    string combo_box_id = "disabled";
    
    UI::ChangeWidget( `id( "rules"), `Value, rules );
    list <string> rules_list = splitstring( rules, "\n" );
    
    foreach ( string rule, rules_list, {
	if ( regexpmatch( rule, "^[ /t]*-e[ /t]*2" ) )
	{
	    combo_box_id = "locked";
	}
	else if ( regexpmatch( rule, "^[ /t]*-e[ /t]*1" ) )
	{
	    combo_box_id = "enabled";
	}
	else if ( regexpmatch( rule, "^[ /t]*-e[ /t]*0" ) )
	{
	    combo_box_id = "disabled";
	}
    } );
    UI::ChangeWidget( `id( "audit_enabled"), `Value, combo_box_id );
    
    y2milestone ( "Init rules dialog" );
}

symbol HandleRulesDialog(string id, map event) {
    any action = event["ID"]:nil; 
 
    if ( action == "audit_enabled" )
    {
	string value = (string)UI::QueryWidget( `id("audit_enabled"), `Value );
	string rule = "";
	string rules = AuditLaf::GetRules();
	list <string> rules_list = [];
	
	y2milestone( "Setting status to: %1", value );

	switch ( value )
	{
	    case "locked": {
		rule = "-e 2";
		break;
	    }
	    case "enabled": {
		rule = "-e 1";
		break;
	    }
	    case "disabled": {
		rule = "-e 0";
		break;
	    }
	}
	
	if ( rules != nil && rules != "")
	{
	    rules_list = splitstring( rules, "\n");
	}

	boolean rule_found = false;
	
	if ( rules_list != [] )
	{
	    list<string> new_rules = maplist( string line, rules_list, {
		if ( regexpmatch( line, "^[ /t]*-e" ) )
		{
		    rule_found = true;
		    return rule;
		}
		else
		{
		    return line;
		}
	    });
	    if ( !rule_found )
		new_rules = add( new_rules, rule );

	    UI::ChangeWidget(`id("rules"), `Value,  mergestring( new_rules, "\n" ) );
	}
    }
    else if ( action == "restore" )
    {
	InitRulesDialog( "restore" );
    }
    else if ( action == "reset" )
    {
	InitRulesDialog( "reset" );

	if ( AuditLaf::RulesAlreadyLocked() )
	{
	    SCR::Execute( .target.bash, "auditctl -D" );
	}
	else
	{
	    integer exit_code = (integer)SCR::Execute( .target.bash, "auditctl -D" );

	    if ( exit_code == 0 )
		exit_code = (integer)SCR::Execute( .target.bash, "auditctl -R /etc/audit/audit.rules" );

	    if ( exit_code == 0 )
		Popup::Message( _("Rules successfully restored" ) );
	    else
		Report::Error( _("Cannot reset rules, please test again" ) );
	}
    }
    else if ( action == "test" )
    {
	boolean go_on = true;
	
	string rules = (string)UI::QueryWidget( `id("rules"), `Value );
	list <string> rules_list = splitstring( rules, "\n");

	if ( AuditLaf::RulesAlreadyLocked() )
	{
	    Report::Warning( _("The rules are already locked.\n
A test isn't possible because sending new rules
will cause an error.") );
	    go_on = false;
	}

	if ( go_on )
	{
	    foreach ( string rule, rules_list, {
		    if ( regexpmatch( rule, "^[ /t]*-e[ /t]*2" ) )
		    {
			Report::Warning( _("Lock is set in audit.rules (-e 2).\n
It doesn't make sense to continue, because the rules would
be locked until next boot.") );
			go_on = false;
		    }
		} );
	}
   
	if ( go_on )
	{
	    string tmpfile = (string) SCR::Read (.target.tmpdir) + "/rules_test_file";
	
	    boolean success = (boolean)SCR::Write(.target.string, tmpfile, rules );
	    if ( success )
	    {
		map output = (map)SCR::Execute(.target.bash_output, sformat( "auditctl -R %1", tmpfile ) );
		if ( output["exit"]:0 != 0 )
		{
		    Report::Error( sformat( output["stderr"]:"" ) );
		}
		else
		{
		    Popup::Message( "Success");
		}
	    }
	    else
	    {
		Report::Error( _("Cannot create tmp file for rules" ) );
	    }
	}
    }
    else if ( action == "load" )
    {
	string file_name = UI::AskForExistingFile("/usr/share/doc/packages/audit", "*.rules", _("Select an example") );
	string example_rules = (string)SCR::Read(.target.string, file_name );
	
	UI::ChangeWidget( `id("rules"), `Value, example_rules );
	y2milestone( "Example rules loaded: %1", file_name );  
    }

    return nil;
}

void StoreRulesDialog( string id, map event) {
    string rules = (string)UI::QueryWidget( `id("rules"), `Value );

    AuditLaf::SetRules( rules );

    y2debug( "RULES: %1", rules );
    y2milestone( "Store rules dialog" );
}

symbol CheckSettings() {
    symbol ret = `next;
    AuditLaf::SetRulesLocked( false );
    
    string rules = AuditLaf::GetRules();
    list <string> rules_list = splitstring( rules, "\n");

    y2milestone( "Checking rules..." );
    
    foreach ( string rule, rules_list, {
	if ( regexpmatch( rule, "^[ /t]*-e[ /t]*2" ) )
	{
	    boolean yes = Popup::AnyQuestion( _("Lock set"), _("The audit configuration is locked (option -e 2).
This means the rules are locked until next boot!
If you really want this, make sure '-e 2' is the last entry
in the rules file. If not, either enable or disable auditing.
To check or to change the rules,
please go back to rules editor."),
					      Label::ContinueButton(),
					      Label::BackButton(),
					      `focus_no );
	    if ( yes )
	    {
		ret = `next;
	    }
	    else
	    {
		ret = `back;
		AuditLaf::SetRulesLocked( true );
	    }
	}
    } );
    
    return ret;
}

/* EOF */
}
