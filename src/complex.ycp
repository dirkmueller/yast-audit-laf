/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	include/audit-laf/complex.ycp
 * Package:	Configuration of Linux Auditing
 * Summary:	Dialogs definitions
 * Authors:	Gabriele Mohr <gs@suse.de>
 *
 */

{

textdomain "audit-laf";

import "Label";
import "Popup";
import "Wizard";
import "Wizard_hw";
import "Confirm";
import "AuditLaf";
import "Report";

include "audit-laf/helps.ycp";

/**
 * Return a modification status
 * @return true if data was modified
 */
boolean Modified() {
    return AuditLaf::Modified();
}

boolean ReallyAbort() {
    return !AuditLaf::Modified() || Popup::ReallyAbort(true);
}

boolean ReallyExit () {
    // yes-no popup
    return Popup::YesNo (_("Really exit?
All changes will be lost."));
}


/**
 * Read settings dialog
 * @return `abort if aborted and `next otherwise
 */
symbol ReadDialog() {
    Wizard::RestoreHelp(HELPS["read"]:"");
    if (!Confirm::MustBeRoot()) return `abort;

    boolean ret = AuditLaf::Read();
    return ret ? `next : `abort;
}

/**
 * Write settings dialog
 * @return `abort if aborted and `next otherwise
 */
symbol WriteDialog() {
    Wizard::RestoreHelp(HELPS["write"]:"");

    boolean ret = AuditLaf::Write();
    return ret ? `next : `abort;
}

/*
 * Init log file dialog (set values to values read with AuditLad::Read())
 */
void InitLogfileSettingsDialog (string id) {

    UI::ChangeWidget( `id("max_log_file"), `ValidChars, "0123456789" );

    // Set all values to values read from /etc/audit/auditd.conf
    UI::ChangeWidget( `id("freq"), `Value, tointeger( AuditLaf::GetAuditdOption("freq")) );
    UI::ChangeWidget( `id("num_logs"), `Value, tointeger( AuditLaf::GetAuditdOption("num_logs")) );		      
    foreach (string key, ["log_file",
			  "max_log_file",
			  "name"
			  ], {
	UI::ChangeWidget(`id(key), `Value, (AuditLaf::GetAuditdOption(key)));
    });

    foreach (string key, ["log_format",
			  "flush",
			  "max_log_file_action",
			  "name_format"
			  ], {
		 UI::ChangeWidget(`id(key), `Value, toupper(AuditLaf::GetAuditdOption(key)) );
		 if ( key == "name_format" )
		 {
		     if ( toupper(AuditLaf::GetAuditdOption(key) ) == "USER" )
			  UI::ChangeWidget( `id("name"), `Enabled, true );
		     else
			 UI::ChangeWidget( `id("name"), `Enabled, false );
		 }
    });

    y2milestone( "Init log file settings");
}

/*
 * Handle actions of log file dialog (button 'Select file')
 */
symbol HandleLogfileSettingsDialog(string id, map event) {
    any action = event["ID"]:nil; 

    if ( action == "select_file" )
    {
	string file_name = UI::AskForSaveFileName("/var/log/audit", "*.log", _("Select the log file") );
	y2milestone( "Filename: %1", file_name );  
	UI::ChangeWidget( `id("log_file"), `Value, file_name );
	y2milestone( "Logfile set to: %1", file_name );  
    }
    else if ( action == "name_format" )
    {
	string option = (string)UI::QueryWidget( `id("name_format"), `Value );
	if ( option == "USER" )
	    UI::ChangeWidget( `id("name"), `Enabled, true );
	else
	    UI::ChangeWidget( `id("name"), `Enabled, false );

    }
    return nil;
}

/*
 * Store all settings made in log file dialog
 */
void StoreLogfileSettingsDialog (string id, map event) {

    AuditLaf::SetModified( true );

    // Store all values in SETTINGS
    AuditLaf::SetAuditdOption( "freq", tostring( (integer)UI::QueryWidget( `id("freq"), `Value ) ) );
    AuditLaf::SetAuditdOption( "num_logs", tostring( (integer)UI::QueryWidget( `id("num_logs"), `Value ) ) ); 

    foreach (string key, ["log_file",
			  "log_format",
			  "max_log_file",
			  "flush",
			  "max_log_file_action",
			  "name_format"
			  ], {
	AuditLaf::SetAuditdOption( key, (string) UI::QueryWidget(`id(key), `Value) );
    });

    if ( AuditLaf::GetAuditdOption( "name_format" ) == "USER" )
    {
	if ( (string) UI::QueryWidget( `id("name"), `Value ) == "" )
	{
	    Report::Error(_("The 'User Defined Name' is NOT set although
the 'Computer Name Format' is set to 'USER'.
Setting the format to 'NONE' (default)." ) );
	    AuditLaf::SetAuditdOption( "name_format", "NONE" );
	}
	else
	{
	    AuditLaf::SetAuditdOption( "name", (string) UI::QueryWidget(`id("name"), `Value) );
	}
    }

    y2milestone( "Store log file settings" );
}

/*
 * Init dispatcher dialog (set values to values read with AuditLad::Read())
 */
void InitDispatcherDialog (string id) {

    // Set all values to values read from /etc/audit/auditd.conf
    foreach (string key, ["dispatcher",
			  "disp_qos" ], {
	UI::ChangeWidget(`id(key), `Value, (AuditLaf::GetAuditdOption(key)));
    });
    
    y2milestone( "Init dispatcher dialog" );
}

/*
 * Handle actions of dispatcher dialog (button 'Select file')
 */
symbol HandleDispatcherDialog(string id, map event) {
    any action = event["ID"]:nil; 

    if ( action == "select_disp" )
    {
	string file_name = UI::AskForExistingFile("/sbin", "*", _("Select the dispatcher program") );

	UI::ChangeWidget( `id("dispatcher"), `Value, file_name );
	y2milestone( "Dispatcher program set to: %1", file_name );  
    }
    return nil;
}

/*
 * Store all settings made in dispatcher dialog
 */
void StoreDispatcherDialog (string id, map event) {

    AuditLaf::SetModified( true );

   // Store all values in SETTINGS
    foreach (string key, ["dispatcher",
			  "disp_qos"], {
	AuditLaf::SetAuditdOption( key, (string) UI::QueryWidget(`id(key), `Value) );
    });

    y2milestone( "Store dispatcher dialog" );
}

/*
 * Init disk space dialog (set values to values read with AuditLad::Read())
 */
void InitDiskspaceSettingsDialog (string id) {
    UI::ChangeWidget( `id("space_left"), `ValidChars, "0123456789" );
    UI::ChangeWidget( `id("admin_space_left"), `ValidChars, "0123456789" );
 
    // Set all values to values read from /etc/audit/auditd.conf
    foreach (string key, ["space_left",
			  "action_mail_acct",
			  "admin_space_left"
			  ], {
	UI::ChangeWidget(`id(key), `Value, (AuditLaf::GetAuditdOption(key)));
    });

    foreach ( string key, ["space_left_action",
			   "admin_space_left_action",
			   "disk_full_action",
			   "disk_error_action"
			   ], {

		  if ( toupper(substring( AuditLaf::GetAuditdOption(key), 0, 4 ) ) == "EXEC" )
		  {
		      UI::ChangeWidget( `id(key), `Value, "EXEC" );
		      UI::ChangeWidget( `id(key+"_exec"), `Enabled, true );
		      UI::ChangeWidget( `id(key+"_exec"), `Value, substring( AuditLaf::GetAuditdOption(key), 5 ) );
		  }
		  else
		  {
		      UI::ChangeWidget( `id(key), `Value, toupper(AuditLaf::GetAuditdOption(key)) );
		      UI::ChangeWidget( `id(key+"_exec"), `Enabled, false ); 
		  }	 
	      });

    y2milestone( "Init disk space settings" );

}

/*
 * Handle actions of disk space
 */
symbol HandleDiskspaceSettingsDialog(string id, map event) {
    any action = event["ID"]:nil; 
    y2milestone( "action: %1", action );
    
    list actions_list = ["space_left_action",
			 "admin_space_left_action",
			 "disk_full_action",
			 "disk_error_action"
			 ];

    if ( is( action, string ) && contains( actions_list, (string)action) )
    {
	string option = (string)UI::QueryWidget(`id((string)action), `Value );
	y2milestone( "Option: %1", option );
	
	if ( option == "EXEC" )
	{
	    UI::ChangeWidget( `id((string)action+"_exec"), `Enabled, true );
	}
	else
	{
	    UI::ChangeWidget( `id((string)action+"_exec"), `Enabled, false ); 
	}
    }
    
    return nil;
}

/*
 * Store all settings made in disk space dialog
 */
void StoreDiskspaceSettingsDialog (string id, map event) {
    string option = "";
    string exec = "";
	
    AuditLaf::SetModified( true );

    foreach ( string key, ["space_left",
			  "action_mail_acct",
			  "admin_space_left"
			  ], {
		 AuditLaf::SetAuditdOption( key, (string) UI::QueryWidget(`id(key), `Value) );
	     });

    foreach ( string key, ["space_left_action",
			   "admin_space_left_action",
			   "disk_full_action",
			   "disk_error_action"
			   ], {

		  option = (string)UI::QueryWidget( `id(key), `Value );
		  if ( option == "EXEC" )
		  {
		      exec = (string)UI::QueryWidget( `id(key+"_exec"), `Value );
		      AuditLaf::SetAuditdOption( key, option + " " + exec ); 
		  }

		  else
		  {
		      AuditLaf::SetAuditdOption( key, option );   
		  }	 
	      });
    
    y2milestone( "Store disk space settings" );
}

/*
 * Init rules dialog
 */
void InitRulesDialog( string id )   {
    string rules = "";
    string combo_box_id = "disabled";

    if ( id == "restore" || id == "reset" )
	rules = AuditLaf::GetInitialRules();
    else
	rules = AuditLaf::GetRules();
    
    UI::ChangeWidget( `id( "rules"), `Value, rules );
    list <string> rules_list = splitstring( rules, "\n" );
    
    foreach ( string rule, rules_list, {
	if ( regexpmatch( rule, "^[ /t]*-e[ /t]*2" ) )
	{
	    combo_box_id = "locked";
	}
	else if ( regexpmatch( rule, "^[ /t]*-e[ /t]*1" ) )
	{
	    combo_box_id = "enabled";
	}
	else if ( regexpmatch( rule, "^[ /t]*-e[ /t]*0" ) )
	{
	    combo_box_id = "disabled";
	}
    } );
    UI::ChangeWidget( `id( "audit_enabled"), `Value, combo_box_id );
    
    y2milestone ( "Init rules dialog" );
}

/*
 * Reset rules - called if button 'Restore and Reset' is pressed or if the user
 * aborts configuration after doing 'Check Syntax' (which changes the rules).
 */
void ResetRules() {
    
	if ( AuditLaf::RulesAlreadyLocked() )
	{
	    // Warning - the audit configuration is locked, reset impossible
	    Report::Warning( _("The rules are already locked, a reset is impossible.\n
If you want to unlock, set the enabled flag accordingly and
finish the configuration. Afterwards a reboot is required.") ); 
	}
	else
	{
	    integer exit_code = (integer)SCR::Execute( .target.bash, "auditctl -D" );

	    if ( exit_code == 0 )
		exit_code = (integer)SCR::Execute( .target.bash, "auditctl -R /etc/audit/audit.rules" );

	    if ( exit_code == 0 )
	    {
		// Report success
		Popup::Message( _("Rules successfully restored" ) );
		AuditLaf::SetRulesChanged( false );
	    }
	    else
		// Report error - error during reset
		Report::Error( _("Cannot reset rules. Please check /etc/audit/audit.rules." ) );
	}
}

/*
 * Handle actions of rules dialog
 */
symbol HandleRulesDialog(string id, map event) {
    any action = event["ID"]:nil; 
 
    if ( action == "audit_enabled" )
    {
	string rule = "";
	list <string> rules_list = [];
	
	string value = (string)UI::QueryWidget( `id("audit_enabled"), `Value );
	string rules =  (string)UI::QueryWidget( `id("rules"), `Value );
	
	y2milestone( "Setting status to: %1", value );

	switch ( value )
	{
	    case "locked": {
		rule = "-e 2";
		break;
	    }
	    case "enabled": {
		rule = "-e 1";
		break;
	    }
	    case "disabled": {
		rule = "-e 0";
		break;
	    }
	}
	
	if ( rules != nil && rules != "")
	{
	    rules_list = splitstring( rules, "\n");
	}

	boolean rule_found = false;
	
	if ( rules_list != [] )
	{
	    list<string> new_rules = maplist( string line, rules_list, {
		if ( regexpmatch( line, "^[ /t]*-e" ) )
		{
		    rule_found = true;
		    return rule;
		}
		else
		{
		    return line;
		}
	    });
	    if ( !rule_found )
		new_rules = add( new_rules, rule );

	    UI::ChangeWidget(`id("rules"), `Value,  mergestring( new_rules, "\n" ) );
	}
    }
    else if ( action == "restore" )
    {
	InitRulesDialog( "restore" );
    }
    else if ( action == "reset" )
    {
	InitRulesDialog( "reset" );

	ResetRules();
    }
    else if ( action == "test" )
    {
	boolean go_on = true;
	
	string rules = (string)UI::QueryWidget( `id("rules"), `Value );
	list <string> rules_list = splitstring( rules, "\n");

	if ( AuditLaf::RulesAlreadyLocked() )
	{
	    Report::Warning( _("The rules are already locked.\n
A test isn't possible because sending new rules
will cause an error.") );
	    go_on = false;
	}

	if ( go_on )
	{
	    foreach ( string rule, rules_list, {
		    if ( regexpmatch( rule, "^[ /t]*-e[ /t]*2" ) )
		    {
			Report::Warning( _("Lock is set in audit.rules (-e 2).\n
It doesn't make sense to continue, because the rules would
be locked until next boot.") );
			go_on = false;
		    }
		} );
	}
   
	if ( go_on )
	{
	    string tmpfile = (string) SCR::Read (.target.tmpdir) + "/rules_test_file";
	
	    boolean success = (boolean)SCR::Write(.target.string, tmpfile, rules );
	    if ( success )
	    {
		map output = (map)SCR::Execute(.target.bash_output, sformat( "auditctl -R %1", tmpfile ) );
		AuditLaf::SetRulesChanged( true );
		
		if ( output["exit"]:0 != 0 )
		{
		    Report::Error( output["stderr"]:"" );
		}
		else
		{
		    Popup::Message( "Success");
		}
	    }
	    else
	    {
		Report::Error( _("Cannot create tmp file for rules" ) );
	    }
	}
    }
    else if ( action == "load" )
    {
	string file_name = UI::AskForExistingFile("/usr/share/doc/packages/audit", "*.rules", _("Select an example") );
	string example_rules = (string)SCR::Read(.target.string, file_name );
	
	UI::ChangeWidget( `id("rules"), `Value, example_rules );
	y2milestone( "Example rules loaded: %1", file_name );  
    }

    return nil;
}

/*
 * Store the rules edited in rules dialog
 */
void StoreRulesDialog( string id, map event) {

    AuditLaf::SetModified( true );

    string rules = (string)UI::QueryWidget( `id("rules"), `Value );

    AuditLaf::SetRules( rules );

    y2debug( "RULES: %1", rules );
    y2milestone( "Store rules dialog" );
}



/*
 * Called if 'Abort' button is pressed in main dialog.
 * If the rules are changed by a syntax check the changes will be reseted.
 */
symbol Reset() {

    if ( AuditLaf::RulesChanged() )
    {
	ResetRules();
    }
}

symbol CheckSettings() {
    symbol ret = `next;
    AuditLaf::SetRulesLocked( false );
    
    string rules = AuditLaf::GetRules();
    list <string> rules_list = splitstring( rules, "\n");

    y2milestone( "Checking rules..." );
    
    foreach ( string rule, rules_list, {
	if ( regexpmatch( rule, "^[ /t]*-e[ /t]*2" ) )
	{
	    boolean yes = Popup::AnyQuestion( _("Lock set"), _("The audit configuration is locked (option -e 2).
This means the rules are locked until next boot!
If you really want this, make sure '-e 2' is the last entry
in the rules file. If not, either enable or disable auditing.
To check or to change the rules, please go back to rules editor."),
					      Label::ContinueButton(),
					      Label::BackButton(),
					      `focus_no );
	    if ( yes )
	    {
		ret = `next;
	    }
	    else
	    {
		ret = `back;
		AuditLaf::SetRulesLocked( true );
	    }
	}
    } );
    
    return ret;
}

/* EOF */
}
