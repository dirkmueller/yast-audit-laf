/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	modules/AuditLaf.ycp
 * Package:	Configuration of audit-laf
 * Summary:	AuditLaf settings, input and output functions
 * Authors:	Gabriele Mohr <gs@suse.de>
 *
 *
 * Representation of the configuration of audit-laf.
 * Input and output routines.
 */

{

module "AuditLaf";
textdomain "audit-laf";

import "Progress";
import "Report";
import "Summary";
import "Message";
import "Popup";
import "Mode";
import "FileUtils";
import "Service";


/**
 * Prototypes
 */
global boolean Modified();

/**
 * Data was modified?
 */
boolean modified = false;

/**
 */
boolean proposal_valid = false;

/**
 * Filename (path) rules file
 */
string rules_file = "/etc/audit/audit.rules";

/**
 * Filename (path) config file
 */
string config_file = "/etc/audit/auditd.conf";

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
boolean write_only = false;

boolean rules_locked = false;

global void SetRulesLocked( boolean value ) {
    rules_locked = value;
}

global boolean RulesLocked() {
    return rules_locked;
}

/**
 * Return rules file path
 */ 
global string GetRulesFile() {
    return rules_file;
}

global string GetConfigFile() {
    return config_file;
}

global list <string> GetWatches() {
    return ( [ "exit,always watch=/etc/passwd perm=rwx",
	       "entry,always watch=/etc/sysconfig/yast2 perm=rwx"] );
}

/**
 * Data was modified?
 * @return true if modified
 */
global boolean Modified() {
    y2milestone("modified=%1",modified);
    return modified;
}

/**
 * Mark as modified, for Autoyast.
 */
global void SetModified(boolean value) {
      modified = true;
  }

/**
 * @return true if module is marked as "write only" (don't start services etc...)
 */
global boolean WriteOnly() {
    return write_only;
}

/**
 * Set write_only flag (for autoinstalation).
 */
global void SetWriteOnly(boolean value) {
    write_only = value;
}

/**
  Returns a confirmation popup dialog whether user wants to really abort.
 */
global boolean Abort() {
    return Popup::ReallyAbort(Modified());
}

/**
 * Checks whether an Abort button has been pressed.
 * If so, calls function to confirm the abort call.
 *
 * @return boolean true if abort confirmed
 */
global boolean PollAbort() {
    // Do not check UI when running in CommandLine mode
    if (Mode::commandline())
	return false;

    if (UI::PollInput() == `abort)
	return Abort();

    return false;
}

global boolean RulesAlreadyLocked()
{
    map output = (map)SCR::Execute( .target.bash_output, "auditctl -s" );
    y2milestone( "auditctl: %1", output );

    string audit_status = output["stdout"]:"";
    
    if ( regexpmatch( audit_status, "^.*enabled=2.*" ) )
	 return true;
    else
	return false;
}

//
// Settings: Define all variables needed for the configuration of the audit daemon
//

/**
 * map of audit settings (from /etc/audit/auditd.conf)
 */
map <string, list <string> > SETTINGS = $[];

/**
 * default settings for /etc/audit/auditd.conf
 */ 
map <string, list <string> >  DEFAULT_CONFIG = $[
					"log_file" : ["/var/log/audit/audit.log"],
					"log_format" : ["RAW"],
					"priority_boost" : ["3"],
					"flush" : ["INCREMENTAL"],
					"freq" : ["20"],
					"num_logs" : ["4"],
					"dispatcher" : ["/sbin/audispd"],
					"disp_qos" : ["lossy"],
					"name_format": ["NONE"],
					"name": [""],
					"max_log_file" : ["5"],
					"max_log_file_action" : ["ROTATE"],
					"space_left" : ["75"],
					"space_left_action" : ["SYSLOG"],
					"action_mail_acct" : ["root"],
					"admin_space_left": ["50"],
					"admin_space_left_action" : ["SUSPEND"],
					"disk_full_action" : ["SUSPEND"],
					"disk_error_action" : ["SUSPEND"]
];

/**
 * Rules for the subsystem audit (passed via auditctl)
 * are read from /etc/audit/audit.rules
 */ 
string RULES = "";

/**
 * Get value of given option from SEETINGS
 */
global string GetAuditdOption( string key) {
    list <string> option_list =  SETTINGS[key]:DEFAULT_CONFIG[key]:[];

    if ( option_list != [] )
	return option_list[0]:"";
    else
	return "";
}

/**
 * Set option to given value in SETTINGS
 */ 

global boolean SetAuditdOption( string key, string value ) {
    list <string> option_list = [];

    if ( value != "" )
    {
	option_list = add( option_list, value );
	SETTINGS[key] = option_list;
	y2milestone( "Setting %1 to %2", key, option_list );
	return true;
    }
    else
	return false;
}

/**
 * Get all rules
 */
global string GetRules() {
    return RULES;
}

/*
 * Set rules
 */ 
global boolean SetRules( string rules ) {
    if ( rules != nil && rules != "" )
    {
	RULES = rules;
	return true;
    }
    else
	return false;
}

/**
 * Read rules from audit.rules
 */ 
boolean ReadAuditRules() {

  string rules = (string)SCR::Read(.target.string, rules_file );

  if ( rules != nil && rules != "" )
  {
      RULES = rules;
      return true;
  }
  else
      return false;
}

/**
 * Write rules to audit.rules
 */ 
boolean WriteAuditRules() {
    boolean success = (boolean)SCR::Write(.target.string, rules_file, RULES );
    // FIXME ??? flush necessary ???
    return success;
}


/**
 * Read settings from auditd.conf
 * @return true on success
 */
boolean ReadAuditdSettings() {

    if ( ! FileUtils::Exists ( config_file) )
	return false;

    list <string> optionsList =  (list <string>) SCR::Dir(.auditd);
    y2milestone( "List of options: %1", optionsList );
		 
    // list all options set in auditd.conf 
    foreach (string key, (list <string>) SCR::Dir(.auditd),
    {
	// and read the value for each of them
	list <string> val = (list <string>) SCR::Read(add(.auditd, key));
	if (val != nil) SETTINGS[key] = val;
    });

    y2milestone("%1 has been read: %2", config_file, SETTINGS);
    return true;
}

/**
 * Read all auditd settings
 * @return true on success
 */
global boolean Read() {
    boolean success = true;
    
    /* AuditLaf read dialog caption */
    string caption = _("Initializing Audit Configuration");

    // Set the right number of stages
    integer steps = 3;

    integer sl = 500;
    sleep(sl);

    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", steps, [
	    /* Progress stage 1/4 */
	    _("Read the configuration for auditd"),
	    /* Progress stage 2/4 */
	    _("Read the rules file"),
	    /* Progress stage 3/4 */
	    _("Check status of auditd")
	    /* Progress stage 3/4 */
	], [
	    /* Progress step 1/3 */
	    _("Reading the configuration..."),
	    /* Progress step 2/3 */
	    _("Reading the rules file..."),
	    /* Progress step 3/3 */
	    _("Cecking status..." ),
	    Message::Finished()
	],
	""
    );

    // read database
    if(PollAbort()) return false;
    Progress::NextStage();

    success = ReadAuditdSettings();
    // Test
    map output = (map)SCR::Execute( .target.bash_output, "auditctl -s" );

    y2milestone( "auditctl: %1", output );
    
    // Report error
    if( !success) Report::Error(_("Cannot read auditd.conf."));
    sleep(sl);

    // read another database
    if(PollAbort()) return false;
    Progress::NextStep();

    success = ReadAuditRules();
    
    /* Error message */
    if(!success) Report::Error(_("Cannot read audit.rules."));
    sleep(sl);

    // read current settings
    if(PollAbort()) return false;
    Progress::NextStage();
    /* Error message */
    if(false) Report::Error(Message::CannotReadCurrentSettings());
    sleep(sl);

    Progress::NextStage();
    integer auditd_stat = Service::Status( "auditd" );
    y2milestone( "Auditd running: %1", (auditd_stat == 0 )?"yes":"no" );

    integer apparmor_stat = (integer)SCR::Execute(.target.bash, "rcapparmor status" );

    y2milestone( "Apparmor loaded: %1", (apparmor_stat == 0 )?"yes":"no" );

    if ( auditd_stat != 0 )
    {
	string message = _("The audit daemon doesn't run.
Do you want to start it now?");

	if (apparmor_stat == 0 )
	    message = _(" The 'apparmor' kernel module is loaded
but the daemon 'auditd' doesn't run. It is recommended
to start the daemon.
Do you want to start it now?" );
	
	boolean start = Popup::YesNoHeadline( _("Auditd not running"),
					      message );
	if ( start )
	{
	    integer exit_code = Service::RunInitScript( "auditd", "start" );
	    if ( exit_code != 0 )
	    {
		boolean go_on = Popup::ContinueCancelHeadline( _("Cannot start the audit daemon" ),
							       _("The reason might be that the rules are locked.
Continue to check the rules. You may change
the 'Enabled Flag' but to make the change
active a reboot is required afterwards." )
							       );
		if ( go_on )
		    return true;
		else
		    return false;
						     
	    }
	}
    }

    if(PollAbort()) return false;
    modified = false;
    return true;
}

/**
 * Write settings to auditd.conf
 * @return true on success
 */
boolean WriteAuditdSettings() {
    boolean success = true;
    
    if ( ! FileUtils::Exists ( config_file ) )
	return false;

    // list all options set in auditd.conf 
    foreach (string key, list <string> value, SETTINGS, {
	// and write each value
	success = (boolean)SCR::Write(add(.auditd, key), value );
    });

    // This is very important
    // it flushes the cache, and stores the configuration on the disk
    SCR::Write(.auditd, nil);
    y2milestone("%1 has been written: %2", config_file, SETTINGS);
    
    return true;
}

/**
 * Write all auditd settings
 * @return true on success
 */
global boolean Write() {
    boolean write_success = true;
    boolean go_on = false; 

    /* Auditd read dialog caption */
    string caption = _("Saving Audit Configuration");

    // set the right number of stages
    integer steps = 2;

    integer sl = 500;
    sleep(sl);

    // Names of the stages
    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
	    /* Progress stage 1/2 */
	    _("Write the settings"),
	    /* Progress stage 2/2 */
	    _("Write the rules")
	], [
	    /* Progress step 1/2 */
	    _("Writing the settings..."),
	    /* Progress step 2/2 */
	    _("Writing the rules..."),
	    Message::Finished()
	],
	""
    );

    // check status of audit rules first
    boolean locked = RulesAlreadyLocked();

    y2milestone ( "Rules already locked: %1", locked?"true":"false" );

    if ( locked )
    {
	boolean write_rules = Popup::YesNoHeadline( _("The rules are already locked." ),
						    _("Do you want to change the 'Enabled Flag'?
If yes, the new rules will be written to /etc/audit/audit.rules.
After that you have to reboot the system.") );
	if ( write_rules )
	    WriteAuditRules();
	
	// don't try to restart the daemon - daemon will stop
	return false;
    }
    
    // write settings
    if ( PollAbort() )  return false;
    Progress::NextStage();

    write_success = WriteAuditdSettings();

    /* Error message */
    if ( write_success )
    {
	// restart auditd
	integer exit_code = Service::RunInitScript( "auditd", "restart" );
	y2milestone( "'auditd restart' returned: %1", exit_code );
	
	if ( exit_code != 0 )
	    Report::Error ( _("Restart of the audit daemon failed" ) );
	else
	    go_on = true;
    }
    else
    {
	Report::Error (_("Cannot write settings to auditd.conf.") );
    }
    
    sleep(sl);

    if ( PollAbort() ) return false;

    Progress::NextStage ();

    if ( go_on && !locked )
    {
	write_success = WriteAuditRules();
    
	/* Error message */
	if( write_success)
	{
	    // call auditctl -R audit.rules
	    map output = (map)SCR::Execute( .target.bash_output, "auditctl -R /etc/audit/audit.rules" );

	    if ( output["exit"]:0 != 0 )
	    {
		Report::Error( sformat( "%1\n%2",
					output["stderr"]:"",
					_("Please start yast2-audit-laf again and check the rules") ) );
	    }
	}
	else
	{
	    Report::Error ( _("Cannot write settings to auditd.rules.") );
	}
	
	sleep(sl);
    }
    
    if ( PollAbort() ) return false;

    return true;
}

/**
 * Get all auditd settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global boolean Import (map settings) {
    // TODO FIXME: your code here (fill the above mentioned variables)...
    return true;
}

/**
 * Dump the auditd settings to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global map Export () {
    // TODO FIXME: your code here (return the above mentioned variables)...
    return $[];
}

/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global list Summary() {
    // TODO FIXME: your code here...
    /* Configuration summary text for autoyast */
    return [ _("Configuration summary..."), [] ];
}

/**
 * Create an overview table with all configured cards
 * @return table items
 */
global list Overview() {
    // TODO FIXME: your code here...
    return [];
}

/**
 * Return packages needed to be installed and removed during
 * Autoinstallation to insure module has all needed software
 * installed.
 * @return map with 2 lists.
 */
global map AutoPackages() {
    // TODO FIXME: your code here...
    return $[ "install":[], "remove":[] ];
}

/* EOF */
}
