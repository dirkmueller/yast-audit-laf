/* ------------------------------------------------------------------------------
 * Copyright (c) 2006 Novell, Inc. All Rights Reserved.
 *
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of version 2 of the GNU General Public License as published by the
 * Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, contact Novell, Inc.
 *
 * To contact Novell about this file by physical or electronic mail, you may find
 * current contact information at www.novell.com.
 * ------------------------------------------------------------------------------
 */

/**
 * File:	modules/AuditLaf.ycp
 * Package:	Configuration of audit-laf
 * Summary:	AuditLaf settings, input and output functions
 * Authors:	Gabriele Mohr <gs@suse.de>
 *
 *
 * Representation of the configuration of audit-laf.
 * Input and output routines.
 */

{

module "AuditLaf";
textdomain "audit-laf";

import "Progress";
import "Report";
import "Summary";
import "Message";
import "Popup";
import "Mode";
import "FileUtils";
import "Service";


/**
 * Prototypes
 */
global boolean Modified();

/**
 * Data was modified?
 */
boolean modified = false;

/**
 */
boolean proposal_valid = false;

/**
 * Filename (path) rules file
 */
string rules_file = "/etc/audit/audit.rules";

/**
 * Filename (path) config file
 */
string config_file = "/etc/audit/auditd.conf";

/**
 * Write only, used during autoinstallation.
 * Don't run services and SuSEconfig, it's all done at one place.
 */
boolean write_only = false;

/*
 * Option "Lock rules" is set (-e 2)
 */ 
boolean rules_locked = false;

/*
 * The rules have been checked
 */
boolean rules_checked = false;


global void SetRulesLocked( boolean value ) {
    rules_locked = value;
}

global boolean RulesLocked() {
    return rules_locked;
}

global void SetRulesChanged( boolean value ) {
    rules_checked = value;
}

global boolean RulesChanged() {
    return rules_checked;
}

/**
 * Return rules file path
 */ 
global string GetRulesFile() {
    return rules_file;
}

global string GetConfigFile() {
    return config_file;
}

// Testing only
global list <string> GetWatches() {
    return ( [ "exit,always watch=/etc/passwd perm=rwx",
	       "entry,always watch=/etc/sysconfig/yast2 perm=rwx"] );
}

/**
 * Data was modified?
 * @return true if modified
 */
global boolean Modified() {
    y2milestone("modified=%1",modified);
    return modified;
}

/**
 * Mark as modified, for Autoyast.
 */
global void SetModified(boolean value) {
      modified = value;
}

global boolean ProposalValid() {
    return proposal_valid;
}

global void SetProposalValid(boolean value) {
    proposal_valid = value;
}

/**
 * @return true if module is marked as "write only" (don't start services etc...)
 */
global boolean WriteOnly() {
    return write_only;
}

/**
 * Set write_only flag (for autoinstalation).
 */
global void SetWriteOnly(boolean value) {
    write_only = value;
}

/**
  Returns a confirmation popup dialog whether user wants to really abort.
 */
global boolean Abort() {
    return Popup::ReallyAbort(Modified());
}

/**
 * Checks whether an Abort button has been pressed.
 * If so, calls function to confirm the abort call.
 *
 * @return boolean true if abort confirmed
 */
global boolean PollAbort() {
    // Do not check UI when running in CommandLine mode
    if (Mode::commandline())
	return false;

    if (UI::PollInput() == `abort)
	return Abort();

    return false;
}

global boolean RulesAlreadyLocked()
{
    map output = (map)SCR::Execute( .target.bash_output, "auditctl -s" );
    y2milestone( "auditctl: %1", output );

    string audit_status = output["stdout"]:"";
    
    if ( regexpmatch( audit_status, "^.*enabled=2.*" ) )
	 return true;
    else
	return false;
}

global string AuditStatus()
{
    map output = (map)SCR::Execute( .target.bash_output, "auditctl -s" );
    y2milestone( "auditctl: %1", output );

    string audit_status = output["stdout"]:"";
    
    if ( regexpmatch( audit_status, "^.*enabled=2.*" ) )
	return _( "The rules for auditctl are locked" );
    else if ( regexpmatch( audit_status, "^.*enabled=1.*" ) )
	return _( "Auditing enabled");
    else
	return _( "Auditing disabled"); 
}

//
// Settings: Define all variables needed for the configuration of the audit daemon
//

/**
 * map of audit settings (from /etc/audit/auditd.conf)
 */
map <string, string > SETTINGS = $[];

/**
 * default settings for /etc/audit/auditd.conf
 */ 
map <string, string >  DEFAULT_CONFIG = $[
					"log_file" : "/var/log/audit/audit.log",
					"log_format" : "RAW",
					"priority_boost" : "3",
					"flush" : "INCREMENTAL",
					"freq" : "20",
					"num_logs" : "4",
					"dispatcher" : "/sbin/audispd",
					"disp_qos" : "lossy",
					"name_format": "NONE",
					"max_log_file" : "5",
					"max_log_file_action" : "ROTATE",
					"space_left" : "75",
					"space_left_action" : "SYSLOG",
					"action_mail_acct" : "root",
					"admin_space_left": "50",
					"admin_space_left_action" : "SUSPEND",
					"disk_full_action" : "SUSPEND",
					"disk_error_action" : "SUSPEND"
];

/**
 * Rules for the subsystem audit (passed via auditctl).
 * Iinitially read from /etc/audit/audit.rules and edited in
 * the rules editor.
 */ 
string RULES = "";

/**
 * Save rules from /etc/audit/audit.rules to be able to restore it
 */
string INITIAL_RULES = "";

/**
 * Get value of given option from SEETINGS
 */
global string GetAuditdOption( string key) {
    return  SETTINGS[key]:DEFAULT_CONFIG[key]:"";
}

/**
 * Set option to given value in SETTINGS
 */ 

global boolean SetAuditdOption( string key, string value ) {

    // Don't set empty values (seems that 'auditd' doesn't like it)
    if ( value != ""  )
    {
	SETTINGS[key] = value;
	y2milestone( "Setting %1 to %2", key, value );
	return true;
    }
    else
	return false;
}

/**
 * Get the current rules
 */
global string GetRules() {
    return RULES;
}

global string GetInitialRules() {
    return INITIAL_RULES;
}
    
/*
 * Set rules
 */ 
global boolean SetRules( string rules ) {
    if ( rules != nil && rules != "" )
    {
	RULES = rules;
	return true;
    }
    else
	return false;
}

/**
 * Read rules from audit.rules
 */ 
boolean ReadAuditRules() {

    string rules = (string)SCR::Read(.target.string, rules_file );

    if ( rules != nil && rules != "" )
    {
	RULES = rules;
	// additionally save initial settings
	INITIAL_RULES = rules;
	return true;
    }
    else
	return false;
}

/**
 * Write rules to audit.rules
 */ 
boolean WriteAuditRules() {
    boolean success = (boolean)SCR::Write(.target.string, rules_file, RULES );

    return success;
}


/**
 * Read settings from auditd.conf
 * @return true on success
 */
boolean ReadAuditdSettings() {

    if ( ! FileUtils::Exists ( config_file) )
	return false;

    list <string> optionsList =  (list <string>) SCR::Dir(.auditd);
    y2milestone( "List of options: %1", optionsList );
		 
    // list all options set in auditd.conf 
    foreach (string key, (list <string>) SCR::Dir(.auditd),
    {
	// and read the value for each of them
	string val = (string) SCR::Read(add(.auditd, key));
	if (val != nil) SETTINGS[key] = val;
    });

    y2milestone("%1 has been read: %2", config_file, SETTINGS);
    return true;
}

global boolean CheckAuditdStatus()
{
    integer auditd_stat = Service::Status( "auditd" );

    if ( auditd_stat != 0 )
    {
	Report::Error( _("Cannot start the audit daemon.
Please check /var/log/messages for auditd errors.
You might use module 'System Log' from group
'Miscellaneous' in YaST2 Control Center.") );
	return false;
    }
    else
	return true;
}

/**
 * Read all auditd settings
 * @return true on success
 */
global boolean Read() {
    boolean success = true;
    
    /* AuditLaf read dialog caption */
    string caption = _("Initializing Audit Configuration");

    // Set the right number of stages
    integer steps = 3;

    integer sl = 500;
    sleep(sl);

    // We do not set help text here, because it was set outside
    Progress::New( caption, " ", steps, [
	    /* Progress stage 1/4 */
	    _("Read the configuration for auditd"),
	    /* Progress stage 2/4 */
	    _("Read the rules file"),
	    /* Progress stage 3/4 */
	    _("Check status of auditd")
	    /* Progress stage 3/4 */
	], [
	    /* Progress step 1/3 */
	    _("Reading the configuration..."),
	    /* Progress step 2/3 */
	    _("Reading the rules file..."),
	    /* Progress step 3/3 */
	    _("Checking status..." ),
	    Message::Finished()
	],
	""
    );

    // read database
    if(PollAbort()) return false;
    Progress::NextStage();

    success = ReadAuditdSettings();
    // Test
    map output = (map)SCR::Execute( .target.bash_output, "auditctl -s" );

    y2milestone( "auditctl: %1", output );
    
    // Report error
    if( !success) Report::Error(_("Cannot read auditd.conf."));
    sleep(sl);

    // read another database
    if(PollAbort()) return false;
    Progress::NextStep();

    success = ReadAuditRules();
    
    /* Error message */
    if(!success) Report::Error(_("Cannot read audit.rules."));
    sleep(sl);

    // read current settings
    if(PollAbort()) return false;
    Progress::NextStage();
    /* Error message */
    if(false) Report::Error(Message::CannotReadCurrentSettings());
    sleep(sl);

    Progress::NextStage();
    integer auditd_stat = Service::Status( "auditd" );
    y2milestone( "Auditd running: %1", (auditd_stat == 0 )?"yes":"no" );

    integer apparmor_stat = (integer)SCR::Execute(.target.bash, "rcapparmor status" );

    y2milestone( "Apparmor loaded: %1", (apparmor_stat == 0 )?"yes":"no" );

    if ( auditd_stat != 0 )
    {
	string message = _("The audit daemon doesn't run.
Do you want to start it now?");

	if (apparmor_stat == 0 )
	    message = _(" The 'apparmor' kernel module is loaded
which needs the audit daemon to log events. 
Do you want to start the daemon now?" );
	
	boolean start = Popup::YesNoHeadline( _("Audit daemon not running"),
					      message );
	if ( start )
	{
	    integer exit_code = Service::RunInitScript( "auditd", "start" );
	    if ( exit_code != 0 )
	    {
		boolean go_on = Popup::ContinueCancelHeadline( _("Cannot start the audit daemon" ),
							       _("The reason might be that the rules are locked.
Continue to check the rules. You can change
the 'Enabled Flag' but to make the change
active a reboot is required afterwards." )
							       );
		if ( go_on )
		    return true;
		else
		    return false;
						     
	    }
	    else
	    {
		CheckAuditdStatus();
		return true;
	    }
	}
    }

    if(PollAbort()) return false;
    modified = false;
    return true;
}

/**
 * Write settings to auditd.conf
 * @return true on success
 */
boolean WriteAuditdSettings() {
    boolean ret = true;
    
    if ( ! FileUtils::Exists ( config_file ) )
	return false;

    // write all options to auditd.conf 
    foreach (string key, string value, SETTINGS, {
	// and write each value
	boolean success = (boolean)SCR::Write(add(.auditd, key), value );
	if ( !success )
	    ret = false;
    });

    // This is very important
    // it flushes the cache, and stores the configuration on the disk
    SCR::Write(.auditd, nil);

    if ( ret )
	y2milestone("%1 has been written: %2", config_file, SETTINGS);

    return ret;
}

/**
 * Write all auditd settings
 * @return true on success
 */
global boolean Write() {
    boolean write_success = true;
    boolean go_on = false; 

    /* Auditd read dialog caption */
    string caption = _("Saving Audit Configuration");

    // set the right number of stages
    integer steps = 2;

    integer sl = 500;
    sleep(sl);

    // Names of the stages
    // We do not set help text here, because it was set outside
    Progress::New(caption, " ", steps, [
	    /* Progress stage 1/2 */
	    _("Write the settings"),
	    /* Progress stage 2/2 */
	    _("Write the rules")
	], [
	    /* Progress step 1/2 */
	    _("Writing the settings..."),
	    /* Progress step 2/2 */
	    _("Writing the rules..."),
	    Message::Finished()
	],
	""
    );

    // check first whether rules are already locked
    boolean locked = RulesAlreadyLocked();

    y2milestone ( "Rules already locked: %1", locked?"true":"false" );

    if ( locked )
    {
	boolean write_rules = Popup::YesNoHeadline( _("The rules are already locked." ),
						    _("Do you want to change the 'Enabled Flag'?
If yes, the new rules will be written to /etc/audit/audit.rules.
After that you have to reboot the system.") );
	if ( write_rules )
	    WriteAuditRules();
	
	// don't try to restart the daemon - daemon will stop
	return false;
    }
    
    // write settings
    if ( PollAbort() )  return false;
    Progress::NextStage();

    write_success = WriteAuditdSettings();

    if ( write_success )
    {
	// restart auditd
	integer exit_code = Service::RunInitScript( "auditd", "restart" );
	y2milestone( "'auditd restart' returned: %1", exit_code );
	
	if ( exit_code != 0 )
	    // Error message
	    Report::Error ( _("Restart of the audit daemon failed" ) );
	else
	    go_on = true;
    }
    else
    {
	// Error message
	Report::Error (_("Cannot write settings to auditd.conf.") );
    }
    
    sleep(sl);

    if ( PollAbort() ) return false;

    Progress::NextStage ();

    if ( go_on && !locked )
    {
	write_success = WriteAuditRules();
    
	/* Error message */
	if( write_success)
	{
	    // call auditctl -R audit.rules
	    map output = (map)SCR::Execute( .target.bash_output, "auditctl -R /etc/audit/audit.rules" );

	    if ( output["exit"]:0 != 0 )
	    {
		Report::Error( sformat( "%1\n%2",
					output["stderr"]:"",
					// Error message, rules cannot be set
					_("Please start yast2-audit-laf again and check the rules") ) );
	    }
	}
	else
	{
	    Report::Error ( _("Cannot write settings to auditd.rules.") );
	}
	
	sleep(sl);
    }

    // Finally check status of auditd (if restart has worked but daemon exited afterwards)
    CheckAuditdStatus();
    
    if ( PollAbort() ) return false;

    return true;
}

/**
 * Get all audit settings from the first parameter
 * (For use by autoinstallation.)
 * @param settings The YCP structure to be imported.
 * @return boolean True on success
 */
global boolean Import ( map settings ) {

    SETTINGS = (map< string, string >)settings ["auditd"]:DEFAULT_CONFIG;
    RULES = (string)settings["rules"]:"";

    SetModified( true );
    y2milestone ("Configuration has been imported");

    return true;
}

/**
 * Dump the auditd settings and the rules to a single map
 * (For use by autoinstallation.)
 * @return map Dumped settings (later acceptable by Import ())
 */
global map Export () {

    return $[
	     "auditd" : SETTINGS,
	     "rules" : RULES
	     ];
}

/**
 * Create a textual summary and a list of unconfigured cards
 * @return summary of the current configuration
 */
global string Summary() {
    string summary = "";

    summary = Summary::AddLine( summary, sformat( "%1: %2", _("Log file"), AuditLaf::GetAuditdOption("log_file")) );
    summary = Summary::AddLine( summary, AuditStatus() );

    y2milestone ( "Summary: %1", summary );
    
    /* Configuration summary text for autoyast */
    return summary;
    
}

/**
 * Create an overview table with all configured cards
 * @return table items
 */
global list Overview() {
    // TODO FIXME: your code here...
    return [];
}

/**
 * Return packages needed to be installed and removed during
 * Autoinstallation to insure module has all needed software
 * installed.
 * @return map with 2 lists.
 */
global map AutoPackages() {
    return $[ "install":["audit"], "remove":[] ];
}

/* EOF */
}
